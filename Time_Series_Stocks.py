#
# Given a time-series of length 260 generated by:
#
# p(t) = 100 + sum[sin(t * c_i)] for c_i in
# c = [46, 64, 98, 99, 101, 104, 106, 107, 109, 110, 111, 111, 111, 115, 115]
#
# Calculate the returns based on the following strategy:
# Hold the stock when it is within the closed interval [98, 101] and
# sell at the end of the time series if still holding.
#
# So, if the time series was:
# [96, 97, 98, 102, 100, 100, 100, 96]
#
# The strategy would (N=do nothing, B=buy, S=sell):
# [N, N, B, S, B, N, N, S]
#
# What is the cumulative percentage return using this strategy:
# 1) simply on a percentage return basis
# e.g., day 1: 10%, day 2: 10%, total return would be 21% after two days.
#
# 2) assuming $1000.00 of starting capital and only purchasing whole "shares"
# Please spend less than an hour on this. Partial solutions are acceptable.
# Consider this a conversation starter.
#
# List your source code and any special instructions required
# to execute it.
#
# Make any reasonable assumptions.

#------------------------------------------------------------------------------
# Compiled with Python 2.7.9

# Assumptions:
#    - Assume the time series is calculated using days; that is, t = days
#    - Start with days value of t = 1
#    - 2*pi*k is the number of revolutions (k) around the unit circle
#    - sin(y) ranges from [-1, 1].
#          It is positive when (0  + 2*pi*k) < y < (pi   + 2*pi*k)
#          It is negative when (pi + 2*pi*k) < y < (2*pi + 2*pi*k)
#          It is zero when y = (0 + 2*pi*k) or y = (pi + 2*pi*k)
#    - Conversions to revolutions represent revolutions arouns the unit circle
#    - Then sin(y) in partial revolutions ranges from [-1,1]
#          It is positive when 0   < y < 1/2
#          It is negative when 1/2 < y < 1
#          It is zero when y = 1/2 or y = 0 or y = 1

import math

def time_series_stocks():

    t = request_time()
    if t <= 0: # Test in case a non-positive input is given
        print "Zero time increment given. No action taken."
        return 0

    stock_price = []

    stock_price.append(100 + sin_value(1))
    (stock_action, hold) = check_first(stock_price)
    if t == 1:
        print  "Only one day given in time series. No returns available"
        print "Price = $%.2f, Action = %s" % (stock_price[0], stock_action[0])
        return 0
    (stock_price, stock_action) = stock_days(t, stock_price, stock_action, hold)

    print stock_price
    print stock_action

    return calculate_returns(stock_price, stock_action)



def stock_days(t, stock_price, stock_action, hold):
    for i in range(2, t + 1): # Increment through the days
        stock_price.append(100 + sin_value(i))
        (stock_action, hold) = check_next(t, stock_price, stock_action, hold)

    return (stock_price, stock_action)

def calculate_returns(stock_price, stock_action):
    (cash, hold, stock_num, stock_val) = (1000, 0, 0, 0)

    for j in range(len(stock_action)):

        if stock_action[j] == "B":
            if j == 0:
                prev = 1000 # Total yield based on previous investment and cash
            else:
                prev = cash + stock_num * stock_price[j-1]
            hold       = 1
            stock_num  = cash/stock_price[j] # Integer Division
            cash      -= stock_price[j] * stock_num


        elif stock_action[j] == "S":
            if j == 0:
                prev = 1000
            else:
                prev = cash + stock_num * stock_price[j-1]
            hold       = 0
            cash      += stock_num * stock_price[j]
            stock_num  = 0

        else:
            if j == 0:
                prev = 1000
            else:
                prev = cash + stock_num * stock_price[j-1]

        print_day(stock_num, stock_price[j], stock_action[j], cash, prev, j)

def print_day(stock_num, price, action, cash, prev, j):
    shares_value = stock_num * price
    valuation    = shares_value + cash
    percentage   = (valuation*1.0 - prev) / prev # Float calculation
    total_perc   = (valuation*1.0 - 1000) / 1000
    print "Day %d - Result %s - Stock Price %d"  % (j+1, action, price)
    print "   Stocks Owned:  %d"     % stock_num
    print "   Cash in hand: $%d"   % cash
    print "   Shares Value: $%d"   % shares_value
    print "   Valuation:    $%d"   % valuation
    print "   Daily Yield:   %.2f%%" % (percentage * 100)
    print "Yield-To-Date: %.2f%%" % (total_perc * 100)
    print


def sin_value(t): # Use revolutions to calculate value

    c = [46, 64, 98, 99, 101, 104, 106, 107, 109, 110, 111, 111, 111, 115, 115]
    diff = 0

    for i in range(len(c)):
        temp  = (c[i] * t)/(2*math.pi)   # Will convert to float notation
        rev   = temp - int(temp)         # Add partial revolution of element
        if rev < 0.5:                    # Rev will be greater than zero
            diff += 1
        elif rev > 0.5:               # Rev will be less than one
            diff -= 1

    return diff


def check_next(t, stock_price, stock_action, hold):
    if (stock_price[-1] <= 101) and (stock_price[-1] >= 98):
        if hold == 1:     # If stock has already been purchased
            stock_action.append("N")
        else: # Will purchase, or turn into a "B"
            stock_action.append("B")
            hold = 1 #Flag a purchased stock

    else:
        if hold == 1:
            stock_action.append("S")
            hold = 0
        else: # Otherwise, nothing happens
            stock_action.append("N")

    return (stock_action, hold)


def check_first(stock_price):
    hold_stock = 0  # Use as a flag for when holding a stock
    if (stock_price[0] <= 101) and (stock_price[0] >= 98):
        stock_action = ["B"]
        hold_stock = 1
    else:
        stock_action = ["N"]

    return (stock_action, hold_stock)


def request_time():

    days = ""
    while days == "":

        try:
            days = int(input("Enter the number of days for the time-series: "))

        except TypeError:
            print "Please enter a numerical value (ex. 1, 20, ...):\n"
            days = ""

    return days


time_series_stocks()
